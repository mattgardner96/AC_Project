# AC_Project

This is my first real project on GitHub, so I'll continue working on the documentation as I go. This project was a bit of a summer project to work on a real need I had, and it ended being easier in some ways (and more difficult in others) than I had expected.

## Introduction
  My portable air conditioner has an Infrared remote control that requires line-of-sight, but I wanted to connect the device to the "Internet of Things," enabling remote access to the unit and turning on the A/C well before I returned to my dorm room. Several weeks later, I solved many of the problems I encountered, and I now have a fully working system!
  My first idea was simple: using an off-the-shelf smart plug and connecting it using wifi. Unfortunately, the A/C is digitally controlled, so button-presses (or IR remote control commands) enable all functions—no dials here. Power cycling the unit resets the default temperature and returns the A/C to a power-off state, so a smart plug would turn off the A/C just fine—without ever restarting it again.
  My next idea would be much more complicated: reading the existing IR remote's signals for each function, storing them, and then replicating those signals using a microcontroller within line-of-sight of the A/C. Using a network connection, I could send a signal to the microcontroller, and the microcontroller would send an IR transmission to the A/C. This approach sounded really, really complicated, but it might have just worked; in the end, this was the path I pursued.
  
## Early Steps
  Using a borrowed Arduino Uno and a Grove Shield, Grove IR Emitter, and Grove IR Receiver, I read all the signals from the air conditioner within the first 24 hours of work on the project; however, understanding those IR signals (produced by some Grove example code and libraries I didn't understand) proved much more challenging. The IR signals sent by the controller were parsed by the example code as 4 8-bit numbers, and sending those same 4 numbers back to the A/C would effectively trigger the appropriate actions. Effectively abstracting the IR signal processing made life much easier, and it's definitely above my skill level to reverse-engineer the control scheme for a proprietary IR remote by hand. Using a series of arrays filled with commands, seemingly random numbers (mapped to each function on the remote; again, proprietary control scheme), and outputs to the Serial Monitor, I wrote an Arduino sketch allowing me to type a command into the Serial Monitor and watch the A/C respond in an instant. Within the first 10 days, I effectively had a command-line interface for my portable air conditioner.
  
## Network Communication: The Hard Part
  While the command line interface was cool, it wasn't actually useful; communication needed to be handled via USB using the Arduino IDE, which wasn't especially applicable for an IoT project designed specifically to control something from outside the room. So the hard part began: connecting my little sendToAC function to the big wide web.
  Of course, an Arduino Uno wouldn't cut it for web communication; not only does the board lack the memory to handle verbose HTML pages, it also has no network interfaces. I decided to upgrade to the newly-released Arduino YÚN REV.2, an updated version of Arduino's flagship IoT microcontroller.
  Packing an ethernet port, SD card slot, USB-A connector, and WiFi, this board can handle all that I would throw at it with no difficulty. These four major components are connected by an Atheros processor running Linux and a full installation of Python 2.7, but here's the best part: all of that extra functionality can be accessed through Arduino sketches using the amazingly powerful (though pathetically documented) Bridge library that connects the programming interface and ATMega32U4 processor directly to the Linux distribution. Upgrading to the YÚN REV.2 changed the game; the microprocessor was actually designed for the work I was about to do, and I could continue my original command-line system with no changes to my code or design. However, I ended up waiting several weeks for the new board to be released, delaying my project considerably.
  After receiving the new board, I got to work on network connectivity: first, I sought to connect to the Arduino locally, then I would extend the functionality to the internet at large.
