# AC_Project

This is my first real project on GitHub, so I'll continue working on the documentation as I go. This was a bit of a summer experiment to work on a need (or maybe something closer to a want) that I had, and it ended up being easier in some ways, and more difficult in others, than I had expected. This document walks through the development cycle in-depth, documenting my ideas, attempts, and solutions, as well as the equipment and tooks that I used to get everything working. The actual README file likely has more direct information about system setup and operation, but I find this file a bit more interesting.

## Introduction
My portable air conditioner has an Infrared remote control that requires line-of-sight, but I wanted to connect the device to the "Internet of Things," enabling remote access to the unit and turning on the A/C well before I returned to my dorm room. Several weeks later, I solved many of the problems I encountered, and I now have a fully working system!
  
My first idea was simple: using an off-the-shelf smart plug and connecting it using wifi. Unfortunately, the A/C is digitally controlled, so button-presses (or IR remote control commands) enable all functions—no dials here. Power cycling the unit resets the default temperature and returns the A/C to a power-off state, so a smart plug would turn off the A/C just fine—without ever restarting it again.
  
My next idea would be much more complicated: reading the existing IR remote's signals for each function, storing them, and then replicating those signals using a microcontroller within line-of-sight of the A/C. Using a network connection, I could send a signal to the microcontroller, and the microcontroller would send an IR transmission to the A/C. This approach sounded really, really complicated, but it might have just worked; in the end, this was the path I pursued.
  
## Early Steps
Using a borrowed Arduino Uno and a Grove Shield, Grove IR Emitter, and Grove IR Receiver, I read all the signals from the air conditioner within the first 24 hours of work on the project; however, understanding those IR signals (produced by some Grove example code and libraries I didn't understand) proved much more challenging. The IR signals sent by the controller were parsed by the example code as 4 8-bit numbers, and sending those same 4 numbers back to the A/C would effectively trigger the appropriate actions.
  
Effectively abstracting the IR signal processing made life much easier, and it's definitely above my skill level at the time of writing to reverse-engineer the control scheme for a proprietary commercial IR remote by hand. Using a series of arrays filled with commands, seemingly random numbers (integers mapped to each function on the remote; again, a proprietary control scheme that I couldn't figure out a protocol for), and outputs to the Serial Monitor, I wrote an Arduino sketch allowing me to type a command into the Serial Monitor and watch the A/C respond in an instant. Within the first 10 days, I effectively had a command-line interface (CLI) for my air conditioner.
  
One important detail that evident in this approach is the issues stemming from unidirectional communication—I have no ability to get status updates from the air conditioner. Unfortunately, that means sending a power signal from afar (when I've forgotten to turn my A/C off in the morning) means that I'll actually be shutting it off when I intend to turn it on.
  
## Network Communication: The Hard Part
While the command line interface was cool, it wasn't actually useful; communication needed to be handled via USB using the Arduino IDE's Serial Monitor, which wasn't especially applicable for an IoT project designed to control something from outside the room. So the hard part began: connecting my little sendToAC function to the big wide web.
  
However, an Arduino Uno isn't very useful for web communication; the board lacks both the memory to handle verbose HTML files and the network interfaces to receive those files in the first place. I decided to upgrade to the newly-released Arduino YÚN REV.2, an updated version of Arduino's flagship IoT board.
  
Packing an ethernet port, SD card slot, USB-A connector, and WiFi, this board can handle all that I would throw at it with no difficulty. These four major components are connected by an Atheros processor running Linux and a full installation of Python 2.7, and all of that extra functionality can be accessed through Arduino sketches using the powerful (though insufficiently documented) Bridge library that connects the programming interface and Atmel AVR processor directly to the Linux distribution. This board was designed exactly for the work I was about to do, and I could build network functionality into my original command-line system with no changes to my code or design. However, the board wasn't yet available when I began my project, so I waited several weeks for the new board to be released, delaying the project timeline considerably.
  
After receiving the new board, I got to work on network connectivity: first, I sought to connect to the Arduino locally (within a router-based LAN) before extending my functionality to the larger WAN and Internet. Once again, the Yún's built-in Bridge library made my life considerably better; building a wireless/LAN version of my CLI wasn't too difficult when the commands were sent using the "Console.h" library, effectively an SSH link to the Yún.
